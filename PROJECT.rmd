---
title: "Flight path monitoring"
author: "Boostao"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

if (!requireNamespace("remotes", quietly = TRUE)) install.packages("remotes")
if (!requireNamespace("sf", quietly = TRUE)) remotes::install_github("r-spatial/sf")
if (!requireNamespace("bcdata", quietly = TRUE)) remotes::install_github("bcgov/bcdata")
if (!requireNamespace("bcmaps", quietly = TRUE)) remotes::install_github("bcgov/bcmaps")
if (!requireNamespace("data.table", quietly = TRUE)) install.packages("data.table")
if (!requireNamespace("lubridate", quietly = TRUE)) install.packages("lubridate")
if (!requireNamespace("terra", quietly = TRUE)) remotes::install_github("rspatial/terra")
if (!requireNamespace("leaflet", quietly = TRUE)) remotes::install_github("rstudio/leaflet")

library(sf)
library(units)
library(terra)
library(bcdata)
library(bcmaps)
library(data.table)
library(lubridate)
library(leaflet)

```

## Flight path monitoring analysis

This document will explain the data manipulation required to conduct flight path analysis of time spent in wild life habitat areas.

The data required for this analysis are:
 - Legal habitat areas
 - Digital elevation model
 - Flightline data
 
## Habitat Areas
```{r habitat_areas}

append_bbox_info <- function(sf_obj) {
  stopifnot(inherits(sf_obj, "sf"))
  # Switch class, store bbox for faster processing later
  geom <- sf::st_geometry(sf_obj)
  cls_ori <- class(sf_obj)
  data.table::setDT(sf_obj)
  data.table::set(
    sf_obj,
    j = c("xmin", "ymin", "xmax", "ymax"),
    value = as.list(data.table::rbindlist(lapply(geom, function(x) as.list(sf::st_bbox(x)))))
  )
  attr(sf_obj, "class") <- cls_ori
  return(sf_obj)
}

# Skeena - Mountaingoat winter habitat 
tmpdir <- file.path(tempdir(),"zipped")
unzip("./data-raw/Habitat/Skeena-mountaingoatwinterhab.shp.ALGORAB.20784.25740.sr.zip", exdir = tmpdir)
Skeena_mountaingoatwinterhab <- sf::st_read(tmpdir, drivers = "ESRI Shapefile", quiet = TRUE)
Skeena_mountaingoatwinterhab[["id"]] <- paste(
  "Skeena-mountaingoatwinterhab",
  Skeena_mountaingoatwinterhab[["OBJECTID"]],
  sep = "."
)
# move id in first position, purely aesthetic
n <- ncol(Skeena_mountaingoatwinterhab)
Skeena_mountaingoatwinterhab <- Skeena_mountaingoatwinterhab[, c(n, 1L:(n-1L))]
unlink(tmpdir, recursive = TRUE)

# Ungulate Winter Range- Approved
# bcdc_search("Ungulate Winter Range")
Ungulate_winterrange_approved <- bcdata::bcdc_get_record("712bd887-7763-4ed3-be46-cdaca5640cc1") |>
  bcdata::bcdc_query_geodata() |>
  bcdata::filter(SPECIES_1 %in% c("M-ORAM", "M-RATA-01", "M-RATA-15")) |>
  bcdata::collect()

# Ungulate Winter Range- Proposed
# bcdc_search("Ungulate Winter Range")
Ungulate_winterrange_proposed <- bcdata::bcdc_get_record("e5c2a2e3-70fc-49e3-9840-87212853e8a2") |>
  bcdata::bcdc_query_geodata() |>
  bcdata::filter(SPECIES_1 %in% c("M-ORAM", "M-RATA-01", "M-RATA-15")) |>
  bcdata::collect()

# Legal Planning Objectives - Current - Polygon
# bcdc_search("Legal Planning Objectives Polygon")
legal_habitat_areas <- bcdata::bcdc_get_record("2c02040c-d7c5-4960-8d04-dea01d6d3e9f") |>
  bcdata::bcdc_query_geodata() |>
  bcdata::filter(
    STRGC_LAND_RSRCE_PLAN_NAME == "Dease-Liard Sustainable Resource Management Plan",
    LEGAL_FEAT_OBJECTIVE == "Caribou Winter Habitat Zones"
  ) |>
  bcdata::collect()

# Non Legal Planning Features - Current - Polygon
# bcdc_search("Non Legal Planning Features Polygon")
non_legal_habitat_areas <- bcdata::bcdc_get_record("5d859a89-f173-4006-82f9-16254de2c1fc") |>
  bcdata::bcdc_query_geodata() |>
  bcdata::filter(
    (
      STRGC_LAND_RSRCE_PLAN_NAME == "Dease-Liard Sustainable Resource Management Plan" &
      NON_LEGAL_FEAT_OBJECTIVE == "High Value Mountain Ungulate Habitat"  
    ) |
    (
      STRGC_LAND_RSRCE_PLAN_NAME == "Lakes District Land and Resource Management Plan" &
      NON_LEGAL_FEAT_OBJECTIVE == "SRMZ3:Caribou Migration Corridor Sub-Zone" &
      NON_LEGAL_FEAT_ATRB_2_VALUE %in% c("Caribou Migration Corridor - High", "Caribou Migration Corridor - Very High")
    ) |
    (
      STRGC_LAND_RSRCE_PLAN_NAME == "Morice Land and Resource Management Plan" &
      NON_LEGAL_FEAT_OBJECTIVE %in% c("Mountain Goat Habitat Areas", "Takla Caribou Winter Range", "Tweedsmuir Caribou:Calving Islands")
    )
  ) |>
  bcdata::collect()

habitat_areas <- rbind(
 Skeena_mountaingoatwinterhab[,"id"],
 Ungulate_winterrange_approved[,"id"],
 Ungulate_winterrange_proposed[,"id"],
 legal_habitat_areas[,"id"],
 non_legal_habitat_areas[,"id"]
) |> append_bbox_info()

# rm(
#  Skeena_mountaingoatwinterhab,
#  Ungulate_winterrange_approved,
#  Ungulate_winterrange_proposed,
#  legal_habitat_areas,
#  non_legal_habitat_areas
# )
# saveRDS(habitat_areas, "./data-raw/Habitat/habitat_areas.rds")
# habitat_areas <- readRDS("./data-raw/Habitat/habitat_areas.rds")

```

## Telemetry
```{r wildlife_telemetry}

# bcdc_search("Wildlife Species Inventory Telemetry Observations")
# Public, nothing after 2015 for Caribou
# Will use as an example
wildlife_telemetry <- bcdata::bcdc_get_record("6d48657f-ab33-43c5-ad40-09bd56140845") |>
  bcdata::bcdc_query_geodata() |>
  bcdata::filter(SPECIES_CODE %in% c("M-RATA"), OBSERVATION_YEAR >= 2015) |>
  bcdata::collect()

wildlife_telemetry[["timestamp"]] <- wildlife_telemetry$OBSERVATION_DATE +
  lubridate::hours(wildlife_telemetry$OBSERVATION_HOUR) +
  lubridate::minutes(wildlife_telemetry$OBSERVATION_MINUTE)

wildlife_telemetry <- wildlife_telemetry[,c("id", "timestamp")] |>
  append_bbox_info()

# saveRDS(wildlife_telemetry, "./data-raw/Habitat/wildlife_telemetry.rds")
# wildlife_telemetry <- readRDS("./data-raw/Habitat/wildlife_telemetry.rds")

```

## Digital Elevation Model
```{r dem}

dem_extract <- function(pts, method = c("simple", "bilinear"), ...) {
  method <- match.arg(method)
  dem <- 
    sf::st_bbox(pts) |> # simplify geometry to retrieve required dem
    sf::st_as_sfc() |> # recast to sfc to allow buffer around
    sf::st_buffer(units::set_units(50, m), nQuadSegs = 1) |> # add a margin to allow bilinear
    sf::st_bbox() |> # recompute bounding box before querying dem
    bcmaps::cded(aoi = _, ...) |> # obtain tiles
    terra::rast() # cast as raster
  terra::extract(
    x = dem, 
    y = sf::st_transform(pts, crs = sf::st_crs(dem)) |> terra::vect(),
    method = method,
    ID = FALSE
  )[,1]
}

```

## Flights

```{r flightlines}

#TODO: Still unsure if we will need a different method depending on format, maybe not
#setClass("flightGPX", contains = c("list"))
#setClass("flightKML", contains = c("list"))
#TODO: Will deal with kml format later, might need to write a custom driver

# Assuming the gpx format stays the same, will use track_points
read_GPX <- function(file) {
  layers_data <- sf::st_layers(file)
  non_empty <- layers_data[["name"]][which(layers_data[["features"]] > 0)] |>
    setNames(nm = _)
    lapply(non_empty, sf::st_read, dsn = file, quiet = TRUE)# |> 
      #`class<-`("flightGPX")
}

flights <- list.files("./data-raw/Heli data/NEH/2021", full.names = TRUE) |>
  setNames(nm = _) |>
  sample(1) |> # sample for now, can do full later
  parallel::mclapply(read_GPX, mc.cores = parallel::detectCores()) # go parallel for faster process

# Process flight by flight? Probably

#TODO: Investigate
# GPS Elevation not reliable unless you can fly below mountains?
# f <- read_GPX("./data-raw/Heli data/NEH/2021/20220317-145549-0032969-139533.gpx")
# pts <- f$track_points[3673:3713,] |> sf::st_geometry()
# gps_ele <- f$track_points[3673:3713,]$ele
# real_ele <- dem_extract(pts, method = "bilinear", check_tiles = FALSE)
# leaflet::leaflet(pts) |> 
#   leaflet::addProviderTiles("OpenTopoMap") |> 
#   leaflet::addMarkers(
#     label = sprintf(
#       "<p>GPS Elevation: %s<br>DEM Elevation: %s</p>",
#       gps_ele,
#       round(real_ele, 2)
#     ) |> lapply(FUN = htmltools::HTML)
#   )

```

## Incursion Zones
```{r incursion_zones}
incursion_zones_distance <- list(
  "High" = units::set_units(c("from" = 0L , "to" = 500L), m),
  "Moderate" = units::set_units(c("from" = 500L, "to" = 1000L), m),
  "Low" = units::set_units(c("from" = 1000L, "to" = 1500L), m)
)
```

## Interface
```{r interface}

#TODO: methods shenanigan dispatching for flightGPX and flightKML?
# flight_analysis <- function(flights, zones, areas) {
#   lapply(flights, flight_process, zones = zones, areas = areas)
# }
# 
# flight_process <- function(flight, zones, areas) {
#   UseMethod("flight_process", )
# }

filter_on_bbox <- function(aoi, sf_obj) {
  sf_obj[
    which(
      .subset2(aoi, "xmin") < .subset2(sf_obj, "xmax") &
      .subset2(aoi, "xmax") > .subset2(sf_obj, "xmin") &
      .subset2(aoi, "ymin") < .subset2(sf_obj, "ymax") &
      .subset2(aoi, "ymax") > .subset2(sf_obj, "ymin")
    ),
  ]
}

# TODO: Document fonction
compute_donut <- function(dist, sf_obj) {
  
  buff_oven <- function() {
    precomputed_dist <- list(
      "0" = sf_obj |> sf::st_geometry() |> sf::st_union()
    )
    function(d) {
      d_char <- as.character(d)
      if (is.null(res <- precomputed_dist[[d_char]])) {
        precomputed_dist[[d_char]] <<- res <- 
          sf::st_geometry(sf_obj) |> sf::st_buffer(d) |> sf::st_union()
      }
      return(res)
    }
  }
  
  buffers <- buff_oven()
  
  bake_donut <- function(d) {
    d <- sort(d)
    sf::st_difference(buffers(d[2]), buffers(d[1]))
  }
  
  if (nrow(sf_obj)) { 
    return(
      c(
        list("In UWR" = buffers("0")),
        lapply(dist, bake_donut),
        list("All" = buffers(do.call(max, dist) |> as.character()))
      )
    )
  }
  
  return(invisible())
}

empty_results <- function(flight, dist) {
  zero <- function(...) as.difftime(0, units = "secs")
  do.call(
    data.table::data.table,
    args = c(
      list(
        "Flight" = flight[["tracks"]][["name"]],
        "In UWR" = zero()
      ),
      lapply(dist, zero),
      list(
        "All" = zero()
      )
    )
  )
}

# TODO : Uncompleted,  apply mean to kept fields
combine_contiguous_duplicates <- function(tp, keep) {
  if (!nrow(tp)) {
    return(tp[,c(keep)])
  }
  drop <- logical(nrow(tp))
  coords <- tp |> sf::st_coordinates()
  i <- 1
  j <- 1
  while (i < nrow(tp)) {
    if (all(coords[i,] == coords[i+1,])) {
      if (length(coords[i-1]) & all(coords[]))
      j <- i
    } else {
      if (j != i) {
        
      }
      j <- i + 1
    }
    i <- i + 1
  }
}

# not same
# not same
# same first
# same second
# same third
# not same
# not same



# Process one flight
flight_process <- function(flight, zones, telemetry, dist, max.altitude = units::set_units(500, m)) {
  
  # Flight track points (contiguous duplicates combined)
  ftp <- flight[["track_points"]] |> combine_contiguous_duplicates(keep = c("ele", "time"))
  
  # Track points geom
  geom <- ftp |> sf::st_geometry()
  
  # Combine contiguous points with the same geometry
  
  # Area of interest
  aoi <- geom |>
    sf::st_bbox() |>
    sf::st_as_sfc() |>
    sf::st_buffer(do.call(max,dist) + units::set_units(50L, m)) |>
    sf::st_transform(sf::st_crs(zones)) |>
    sf::st_bbox()
  
  # Zones of interest
  zoi <- filter_on_bbox(aoi, zones)
  
  # Telemetry of interest
  #TODO: Consider data time for telemetry?
  # toi <- filter_on_bbox(aoi, telemetry)
  
  if (nrow(zoi) == 0L) { return(empty_results(flight, dist)) } # No time to account for

  # Incursion
  incursions_zoi <- compute_donut(dist, zoi)
  # incursions_toi <- compute_donut(dist, toi)
  
  # Points of interest
  # Points that intersect with the largest zone + the points before and after to create
  # the LINESTRING at the zone entry
  poi <- geom |>
    sf::st_transform(crs = sf::st_crs(incursions_zoi[["All"]])) |>
    sf::st_intersects(incursions_zoi[["All"]], sparse = FALSE) |>
    # Extract index, add neighbor points, pmin/pmax to stay within valid points
    which() |> {\(x) c(pmax(0,x-1),x,pmin(x+1,length(geom)))}() |>
    # Remove duplicates, sort indexes, subset track points
    unique() |> sort() |> {\(x) ftp[x,]}()
  
  if (nrow(poi) == 0L) { return(empty_results(flight, dist)) } # No time to account for
  
  # Digital elevation model
  dem <- bcmaps::cded(aoi, check_tiles = FALSE) |> terra::rast()
  
  # Get ground level of points of interest
  poi[["ground_ele"]] <- 
    terra::extract(
      x = dem, 
      y = poi |>
        sf::st_geometry() |>
        sf::st_transform(crs = sf::st_crs(dem)) |>
        terra::vect(),
      method = "bilinear",
      ID = FALSE
    )[,1]
  
  # Above ground level (sometimes source elevation is wrong)
  # This is where we might want to do some smoothing if flight ele is bad
  # Currently do same as python, limit to 0L
  poi[["agl"]] <- pmax(poi[["ele"]] - poi[["ground_ele"]], 0) |> units::set_units(m)
  
  # Transform points of interest to LINESTRING of interest
  loi <- sf::st_union(
    sf::st_geometry(poi)[-1],
    sf::st_geometry(poi)[-nrow(poi)],
    by_feature = TRUE
  ) |> sf::st_cast("LINESTRING") |> sf::st_as_sf()
  
  # Won't be using 3D distance as length calculation are for relative
  # ratio only, 3D would not have a large enought impact on hypothesis
  
  # Add line of interest metadata, above ground levels, time deltas
  loi[["agl_start"]] <- poi[["agl"]][-1]
  loi[["agl_end"]] <- poi[["agl"]][-nrow(poi)]
  loi[["time_deltas"]] <- difftime(
    poi[["time"]][-1], 
    poi[["time"]][-nrow(poi)],
    units = "secs"
  )
  
  # Drop line of interest above max.altitude threshold
  loi <- loi[which(loi[["agl_start"]] < max.altitude & loi[["agl_end"]] < max.altitude),]
  if (nrow(loi) == 0L) { return(empty_results(flight, dist)) } # No time to account for
  
  # Compute original length of linestring before apply incursion zones / viewshed masks
  loi[["unmasked_length"]] <- sf::st_length(loi |> sf::st_geometry())
  
  # lots of zero length, combine contiguous before processing further
  
  # Multiply by time delta
  
  # Do viewshed
  terra::viewshed()
  
}

# system.time({test <- sf::st_crop(zones, aoi)})
# system.time({
#   test2 <- zones[
#     which(
#       .subset2(aoi, "xmin") < .subset2(zones, "xmax") &
#       .subset2(aoi, "xmax") > .subset2(zones, "xmin") &
#       .subset2(aoi, "ymin") < .subset2(zones, "ymax") &
#       .subset2(aoi, "ymax") > .subset2(zones, "ymin")),
#   ]
# })
# ggplot2::ggplot() + ggplot2::geom_sf(data = test) + ggplot2::geom_sf(data = flight$tracks)
# ggplot2::ggplot() + ggplot2::geom_sf(data = test2) + ggplot2::geom_sf(data = flight$tracks)
# 
# Run from the function above
flight <- read_GPX("./data-raw/Heli data/NEH/2021/20220214-162736-0031550-139533.gpx")
zones <- habitat_areas
telemetry <- wildlife_telemetry
dist <- incursion_zones_distance

library(ggplot2)
ggplot() +
  geom_sf(data = incursions_zoi[[3]], fill = "beige") +
  geom_sf(data = incursions_zoi[[2]], fill = "yellow") +
  geom_sf(data = incursions_zoi[[1]], fill = "orange") +
  geom_sf(data = zoi, fill = "red") +
  geom_sf(data = flight$tracks |> sf::st_geometry(), colour = "blue")

```

