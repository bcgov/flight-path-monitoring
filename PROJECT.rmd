---
title: "Flight path monitoring"
author: "Boostao"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

if (!requireNamespace("remotes", quietly = TRUE)) install.packages("remotes")
if (!requireNamespace("sf", quietly = TRUE)) remotes::install_github("r-spatial/sf")
if (!requireNamespace("bcdata", quietly = TRUE)) remotes::install_github("bcgov/bcdata")
if (!requireNamespace("bcmaps", quietly = TRUE)) remotes::install_github("bcgov/bcmaps")
if (!requireNamespace("data.table", quietly = TRUE)) install.packages("data.table")
if (!requireNamespace("lubridate", quietly = TRUE)) install.packages("lubridate")
if (!requireNamespace("terra", quietly = TRUE)) remotes::install_github("rspatial/terra")
if (!requireNamespace("leaflet", quietly = TRUE)) remotes::install_github("rstudio/leaflet")

library(bcdata)
library(lubridate)
library(leaflet)

devtools::load_all()
```

## Flight path monitoring analysis

This document will explain the data manipulation required to conduct flight path analysis of time spent in wild life habitat areas.

The data required for this analysis are:
 - Legal habitat areas
 - Digital elevation model
 - Flightline data
 
## Habitat Areas
```{r habitat_areas}

presaved <- "./data-raw/Habitat/habitat_areas.rds"

if (!file.exists(presaved)) {
  
  # Skeena - Mountaingoat winter habitat 
  tmpdir <- file.path(tempdir(),"zipped")
  unzip("./data-raw/Habitat/Skeena-mountaingoatwinterhab.shp.ALGORAB.20784.25740.sr.zip", exdir = tmpdir)
  Skeena_mountaingoatwinterhab <- sf::st_read(tmpdir, drivers = "ESRI Shapefile", quiet = TRUE)
  Skeena_mountaingoatwinterhab[["id"]] <- paste(
    "Skeena-mountaingoatwinterhab",
    Skeena_mountaingoatwinterhab[["OBJECTID"]],
    sep = "."
  )
  # move id in first position, purely aesthetic
  n <- ncol(Skeena_mountaingoatwinterhab)
  Skeena_mountaingoatwinterhab <- Skeena_mountaingoatwinterhab[, c(n, 1L:(n-1L))]
  unlink(tmpdir, recursive = TRUE)
  
  # Ungulate Winter Range- Approved
  # bcdc_search("Ungulate Winter Range")
  Ungulate_winterrange_approved <- bcdata::bcdc_get_record("712bd887-7763-4ed3-be46-cdaca5640cc1") |>
    bcdata::bcdc_query_geodata() |>
    bcdata::filter(SPECIES_1 %in% c("M-ORAM", "M-RATA-01", "M-RATA-15")) |>
    bcdata::collect()
  
  # Ungulate Winter Range- Proposed
  # bcdc_search("Ungulate Winter Range")
  Ungulate_winterrange_proposed <- bcdata::bcdc_get_record("e5c2a2e3-70fc-49e3-9840-87212853e8a2") |>
    bcdata::bcdc_query_geodata() |>
    bcdata::filter(SPECIES_1 %in% c("M-ORAM", "M-RATA-01", "M-RATA-15")) |>
    bcdata::collect()
  
  # Legal Planning Objectives - Current - Polygon
  # bcdc_search("Legal Planning Objectives Polygon")
  legal_habitat_areas <- bcdata::bcdc_get_record("2c02040c-d7c5-4960-8d04-dea01d6d3e9f") |>
    bcdata::bcdc_query_geodata() |>
    bcdata::filter(
      STRGC_LAND_RSRCE_PLAN_NAME == "Dease-Liard Sustainable Resource Management Plan",
      LEGAL_FEAT_OBJECTIVE == "Caribou Winter Habitat Zones"
    ) |>
    bcdata::collect()
  
  # Non Legal Planning Features - Current - Polygon
  # bcdc_search("Non Legal Planning Features Polygon")
  non_legal_habitat_areas <- bcdata::bcdc_get_record("5d859a89-f173-4006-82f9-16254de2c1fc") |>
    bcdata::bcdc_query_geodata() |>
    bcdata::filter(
      (
        STRGC_LAND_RSRCE_PLAN_NAME == "Dease-Liard Sustainable Resource Management Plan" &
        NON_LEGAL_FEAT_OBJECTIVE == "High Value Mountain Ungulate Habitat"  
      ) |
      (
        STRGC_LAND_RSRCE_PLAN_NAME == "Lakes District Land and Resource Management Plan" &
        NON_LEGAL_FEAT_OBJECTIVE == "SRMZ3:Caribou Migration Corridor Sub-Zone" &
        NON_LEGAL_FEAT_ATRB_2_VALUE %in% c("Caribou Migration Corridor - High", "Caribou Migration Corridor - Very High")
      ) |
      (
        STRGC_LAND_RSRCE_PLAN_NAME == "Morice Land and Resource Management Plan" &
        NON_LEGAL_FEAT_OBJECTIVE %in% c("Mountain Goat Habitat Areas", "Takla Caribou Winter Range", "Tweedsmuir Caribou:Calving Islands")
      )
    ) |>
    bcdata::collect()
  
  habitat_areas <- rbind(
   Skeena_mountaingoatwinterhab[,"id"],
   Ungulate_winterrange_approved[,"id"],
   Ungulate_winterrange_proposed[,"id"],
   legal_habitat_areas[,"id"],
   non_legal_habitat_areas[,"id"]
  ) |> append_bbox_info()
  
  rm(
   Skeena_mountaingoatwinterhab,
   Ungulate_winterrange_approved,
   Ungulate_winterrange_proposed,
   legal_habitat_areas,
   non_legal_habitat_areas
  )
  saveRDS(habitat_areas, presaved)

} else {
  
  habitat_areas <- readRDS(presaved)
  
}

```

## Telemetry
```{r wildlife_telemetry}

presaved <- "./data-raw/Habitat/wildlife_telemetry.rds"

if (!file.exists(presaved)) {
  
  # bcdc_search("Wildlife Species Inventory Telemetry Observations")
  # Public, nothing after 2015 for Caribou
  # Will use as an example
  wildlife_telemetry <- bcdata::bcdc_get_record("6d48657f-ab33-43c5-ad40-09bd56140845") |>
    bcdata::bcdc_query_geodata() |>
    bcdata::filter(SPECIES_CODE %in% c("M-RATA"), OBSERVATION_YEAR >= 2015) |>
    bcdata::collect()
  
  wildlife_telemetry[["timestamp"]] <- wildlife_telemetry$OBSERVATION_DATE +
    lubridate::hours(wildlife_telemetry$OBSERVATION_HOUR) +
    lubridate::minutes(wildlife_telemetry$OBSERVATION_MINUTE)
  
  wildlife_telemetry <- wildlife_telemetry[,c("id", "timestamp")] |>
    append_bbox_info()
  
  saveRDS(wildlife_telemetry, presaved)  
  
} else {
  
  wildlife_telemetry <- readRDS(presaved)
  
}

```

## Digital Elevation Model
```{r dem}

# Example use
# dem_extract <- function(pts, method = c("simple", "bilinear"), ...) {
#   method <- match.arg(method)
#   dem <- 
#     sf::st_bbox(pts) |> # simplify geometry to retrieve required dem
#     sf::st_as_sfc() |> # recast to sfc to allow buffer around
#     sf::st_buffer(units::set_units(50, m), nQuadSegs = 1) |> # add a margin to allow bilinear
#     sf::st_bbox() |> # recompute bounding box before querying dem
#     bcmaps::cded(aoi = _, ...) |> # obtain tiles
#     terra::rast() # cast as raster
#   terra::extract(
#     x = dem, 
#     y = sf::st_transform(pts, crs = sf::st_crs(dem)) |> terra::vect(),
#     method = method,
#     ID = FALSE
#   )[,1]
# }

```

## Flights

```{r flightlines}

#TODO: Still unsure if we will need a different method depending on format, maybe not
#setClass("flightGPX", contains = c("list"))
#setClass("flightKML", contains = c("list"))
#TODO: Will deal with kml format later, might need to write a custom driver


# flights <- list.files("./data-raw/Heli data/NEH/2021", full.names = TRUE) |>
#   setNames(nm = _) |>
#   sample(1) |> # sample for now, can do full later
#   parallel::mclapply(read_GPX, mc.cores = ifelse(isTRUE(Sys.info()[["sysname"]]=="Windows"), 1L, parallel::detectCores())) # go parallel for faster process

# Process flight by flight? Probably

#TODO: Investigate
# GPS Elevation not reliable unless you can fly below mountains?
# f <- read_GPX("./data-raw/Heli data/NEH/2021/20220317-145549-0032969-139533.gpx")
# pts <- f$track_points[3673:3713,] |> sf::st_geometry()
# gps_ele <- f$track_points[3673:3713,]$ele
# real_ele <- dem_extract(pts, method = "bilinear", check_tiles = FALSE)
# leaflet::leaflet(pts) |> 
#   leaflet::addProviderTiles("OpenTopoMap") |> 
#   leaflet::addMarkers(
#     label = sprintf(
#       "<p>GPS Elevation: %s<br>DEM Elevation: %s</p>",
#       gps_ele,
#       round(real_ele, 2)
#     ) |> lapply(FUN = htmltools::HTML)
#   )

```

## Incursion Zones
```{r incursion_zones}
incursion_zones_distance <- list(
  "High" = units::set_units(c("from" = 0L , "to" = 500L), m),
  "Moderate" = units::set_units(c("from" = 500L, "to" = 1000L), m),
  "Low" = units::set_units(c("from" = 1000L, "to" = 1500L), m)
)
```

## Example
```{r testit}

flight <- read_GPX("./data-raw/Heli data/NEH/2021/20220214-162736-0031550-139533.gpx")

processed <- flight_process(
  flight = flight,
  zones = habitat_areas,
  telemetry = wildlife_telemetry,
  dist = incursion_zones_distance
)

library(ggplot2)
ggplot() +
  geom_sf(data = processed$`Incursion zones`$Low, fill = "beige") +
  geom_sf(data = processed$`Incursion zones`$Moderate, fill = "yellow") +
  geom_sf(data = processed$`Incursion zones`$High, fill = "orange") +
  geom_sf(data = processed$`Incursion zones`$`In UWR`, fill = "red") +
  geom_sf(data = flight$tracks |> sf::st_geometry(), colour = "lightgreen")+
  geom_sf(data = processed$Segments$`In UWR` |> sf::st_geometry(), colour = "darkblue") +
  geom_sf(data = processed$Segments$High |> sf::st_geometry(), colour = "blue") +
  geom_sf(data = processed$Segments$Moderate |> sf::st_geometry(), colour = "cornflowerblue") +
  geom_sf(data = processed$Segments$Low |> sf::st_geometry(), colour = "skyblue")

print(processed$Summary)
  
```

