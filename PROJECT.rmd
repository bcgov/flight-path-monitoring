---
title: "Flight path monitoring"
author: "Boostao"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

if (!requireNamespace("remotes", quietly = TRUE)) install.packages("remotes")
if (!requireNamespace("sf", quietly = TRUE)) remotes::install_github("r-spatial/sf")
if (!requireNamespace("bcdata", quietly = TRUE)) remotes::install_github("bcgov/bcdata")
if (!requireNamespace("bcmaps", quietly = TRUE)) remotes::install_github("bcgov/bcmaps")
if (!requireNamespace("data.table", quietly = TRUE)) install.packages("data.table")
if (!requireNamespace("lubridate", quietly = TRUE)) install.packages("lubridate")
if (!requireNamespace("terra", quietly = TRUE)) remotes::install_github("rspatial/terra")
if (!requireNamespace("leaflet", quietly = TRUE)) remotes::install_github("rstudio/leaflet")

library(sf)
library(units)
library(terra)
library(bcdata)
library(bcmaps)
library(data.table)
library(lubridate)
library(leaflet)

```

## Flight path monitoring analysis

This document will explain the data manipulation required to conduct flight path analysis of time spent in wild life habitat areas.

The data required for this analysis are:
 - Legal habitat areas
 - Digital elevation model
 - Flightline data
 
## Habitat Areas
```{r habitat_areas}

append_bbox_info <- function(sf_obj) {
  stopifnot(inherits(sf_obj, "sf"))
  # Switch class, store bbox for faster processing later
  cls_ori <- class(sf_obj)
  data.table::setDT(sf_obj)
  data.table::set(
    sf_obj,
    j = c("xmin", "ymin", "xmax", "ymax"),
    value = as.list(data.table::rbindlist(lapply(sf::st_geometry(sf_obj), function(x) as.list(sf::st_bbox(x)))))
  )
  attr(sf_obj, "class") <- cls_ori
  return(sf_obj)
}

# Skeena - Mountaingoat winter habitat 
tmpdir <- file.path(tempdir(),"zipped")
unzip("./data-raw/Habitat/Skeena-mountaingoatwinterhab.shp.ALGORAB.20784.25740.sr.zip", exdir = tmpdir)
Skeena_mountaingoatwinterhab <- sf::st_read(tmpdir, drivers = "ESRI Shapefile", quiet = TRUE)
Skeena_mountaingoatwinterhab[["id"]] <- paste(
  "Skeena-mountaingoatwinterhab",
  Skeena_mountaingoatwinterhab[["OBJECTID"]],
  sep = "."
)
# move id in first position, purely aesthetic
n <- ncol(Skeena_mountaingoatwinterhab)
Skeena_mountaingoatwinterhab <- Skeena_mountaingoatwinterhab[, c(n, 1L:(n-1L))]
unlink(tmpdir, recursive = TRUE)

# Ungulate Winter Range- Approved
# bcdc_search("Ungulate Winter Range")
Ungulate_winterrange_approved <- bcdata::bcdc_get_record("712bd887-7763-4ed3-be46-cdaca5640cc1") |>
  bcdata::bcdc_query_geodata() |>
  bcdata::filter(SPECIES_1 %in% c("M-ORAM", "M-RATA-01", "M-RATA-15")) |>
  bcdata::collect()

# Ungulate Winter Range- Proposed
# bcdc_search("Ungulate Winter Range")
Ungulate_winterrange_proposed <- bcdata::bcdc_get_record("e5c2a2e3-70fc-49e3-9840-87212853e8a2") |>
  bcdata::bcdc_query_geodata() |>
  bcdata::filter(SPECIES_1 %in% c("M-ORAM", "M-RATA-01", "M-RATA-15")) |>
  bcdata::collect()

# Legal Planning Objectives - Current - Polygon
# bcdc_search("Legal Planning Objectives Polygon")
legal_habitat_areas <- bcdata::bcdc_get_record("2c02040c-d7c5-4960-8d04-dea01d6d3e9f") |>
  bcdata::bcdc_query_geodata() |>
  bcdata::filter(
    STRGC_LAND_RSRCE_PLAN_NAME == "Dease-Liard Sustainable Resource Management Plan",
    LEGAL_FEAT_OBJECTIVE == "Caribou Winter Habitat Zones"
  ) |>
  bcdata::collect()

# Non Legal Planning Features - Current - Polygon
# bcdc_search("Non Legal Planning Features Polygon")
non_legal_habitat_areas <- bcdata::bcdc_get_record("5d859a89-f173-4006-82f9-16254de2c1fc") |>
  bcdata::bcdc_query_geodata() |>
  bcdata::filter(
    (
      STRGC_LAND_RSRCE_PLAN_NAME == "Dease-Liard Sustainable Resource Management Plan" &
      NON_LEGAL_FEAT_OBJECTIVE == "High Value Mountain Ungulate Habitat"  
    ) |
    (
      STRGC_LAND_RSRCE_PLAN_NAME == "Lakes District Land and Resource Management Plan" &
      NON_LEGAL_FEAT_OBJECTIVE == "SRMZ3:Caribou Migration Corridor Sub-Zone" &
      NON_LEGAL_FEAT_ATRB_2_VALUE %in% c("Caribou Migration Corridor - High", "Caribou Migration Corridor - Very High")
    ) |
    (
      STRGC_LAND_RSRCE_PLAN_NAME == "Morice Land and Resource Management Plan" &
      NON_LEGAL_FEAT_OBJECTIVE %in% c("Mountain Goat Habitat Areas", "Takla Caribou Winter Range", "Tweedsmuir Caribou:Calving Islands")
    )
  ) |>
  bcdata::collect()

habitat_areas <- rbind(
 Skeena_mountaingoatwinterhab[,"id"],
 Ungulate_winterrange_approved[,"id"],
 Ungulate_winterrange_proposed[,"id"],
 legal_habitat_areas[,"id"],
 non_legal_habitat_areas[,"id"]
) |> append_bbox_info()

# rm(
#  Skeena_mountaingoatwinterhab,
#  Ungulate_winterrange_approved,
#  Ungulate_winterrange_proposed,
#  legal_habitat_areas,
#  non_legal_habitat_areas
# )
# saveRDS(habitat_areas, "./data-raw/Habitat/habitat_areas.rds")
# habitat_areas <- readRDS("./data-raw/Habitat/habitat_areas.rds")

```

## Telemetry
```{r wildlife_telemetry}

# bcdc_search("Wildlife Species Inventory Telemetry Observations")
# Public, nothing after 2015 for Caribou
# Will use as an example
wildlife_telemetry <- bcdata::bcdc_get_record("6d48657f-ab33-43c5-ad40-09bd56140845") |>
  bcdata::bcdc_query_geodata() |>
  bcdata::filter(SPECIES_CODE %in% c("M-RATA"), OBSERVATION_YEAR >= 2015) |>
  bcdata::collect()

wildlife_telemetry[["timestamp"]] <- wildlife_telemetry$OBSERVATION_DATE +
  lubridate::hours(wildlife_telemetry$OBSERVATION_HOUR) +
  lubridate::minutes(wildlife_telemetry$OBSERVATION_MINUTE)

wildlife_telemetry <- wildlife_telemetry[,c("id", "timestamp")] |>
  append_bbox_info()

# saveRDS(wildlife_telemetry, "./data-raw/Habitat/wildlife_telemetry.rds")
# wildlife_telemetry <- readRDS("./data-raw/Habitat/wildlife_telemetry.rds")

```

## Digital Elevation Model
```{r dem}

dem_extract <- function(pts, method = c("simple", "bilinear"), ...) {
  method <- match.arg(method)
  dem <- 
    sf::st_bbox(pts) |> # simplify geometry to retrieve required dem
    sf::st_as_sfc() |> # recast to sfc to allow buffer around
    sf::st_buffer(units::set_units(50, m), nQuadSegs = 1) |> # add a margin to allow bilinear
    sf::st_bbox() |> # recompute bounding box before querying dem
    bcmaps::cded(aoi = _, ...) |> # obtain tiles
    terra::rast() # cast as raster
  terra::extract(
    x = dem, 
    y = sf::st_transform(pts, crs = sf::st_crs(dem)) |> terra::vect(),
    method = method,
    ID = FALSE
  )[,1]
}

```

## Flights

```{r flightlines}

#TODO: Still unsure if we will need a different method depending on format, maybe not
setClass("flightGPX", contains = c("list"))
setClass("flightKML", contains = c("list"))
#TODO: Will deal with kml format later, might need to write a custom driver

# Assuming the gpx format stays the same, will use track_points
read_GPX <- function(file) {
  layers_data <- sf::st_layers(file)
  non_empty <- layers_data[["name"]][which(layers_data[["features"]] > 0)] |>
    setNames(nm = _)
    lapply(non_empty, sf::st_read, dsn = file, quiet = TRUE) |> 
      `class<-`("flightGPX")
}

flights <- list.files("./data-raw/Heli data/NEH/2021", full.names = TRUE) |>
  sample(32) |> # sample for now, can do full later
  parallel::mclapply(read_GPX, mc.cores = parallel::detectCores()) # go parallel for faster process

# Process flight by flight? Probably

#TODO: Investigate
# GPS Elevation not reliable unless you can fly below mountains?
f <- read_GPX("./data-raw/Heli data/NEH/2021/20220317-145549-0032969-139533.gpx")
pts <- f$track_points[3673:3713,] |> sf::st_geometry()
gps_ele <- f$track_points[3673:3713,]$ele
real_ele <- dem_extract(pts, method = "bilinear", check_tiles = FALSE)
leaflet::leaflet(pts) |> 
  leaflet::addProviderTiles("OpenTopoMap") |> 
  leaflet::addMarkers(
    label = sprintf(
      "<p>GPS Elevation: %s<br>DEM Elevation: %s</p>",
      gps_ele,
      round(real_ele, 2)
    ) |> lapply(FUN = htmltools::HTML)
  )

```

## Incursion Zones
```{r incursion_zones}
incursion_zones_distance <- list(
  "0-500 m incursion zone" = units::set_units(c("from" = 0L , "to" = 500L), m),
  "500-1000m incursion zone" = units::set_units(c("from" = 500L, "to" = 1000L), m),
  "1000-1500m incursion zone" = units::set_units(c("from" = 1000L, "to" = 1500L), m)
)
```

## Interface
```{r interface}

#TODO: methods shenanigan dispatching for flightGPX and flightKML?
# flight_analysis <- function(flights, zones, areas) {
#   lapply(flights, flight_process, zones = zones, areas = areas)
# }
# 
# flight_process <- function(flight, zones, areas) {
#   UseMethod("flight_process", )
# }

filter_on_bbox <- function(aoi, sf_obj) {
  sf_obj[
    which(
      .subset2(aoi, "xmin") < .subset2(sf_obj, "xmax") &
      .subset2(aoi, "xmax") > .subset2(sf_obj, "xmin") &
      .subset2(aoi, "ymin") < .subset2(sf_obj, "ymax") &
      .subset2(aoi, "ymax") > .subset2(sf_obj, "ymin")
    ),
  ]
}

compute_donut <- function(dist, sf_obj) {
  
  bake_donut <- function(d) {
      
    if (d["from"] != units::set_units(0, m)) {
      from <- sf_obj |> sf::st_geometry() |> sf::st_buffer(d["from"])
    } else {
      from <- sf_obj |> sf::st_geometry()
    }
    
    if (d["to"] != units::set_units(0, m)) {
      to <- sf_obj |> sf::st_geometry() |> sf::st_buffer(d["to"])
    } else {
      to <- sf_obj |> sf::st_geometry()
    }
    
    if (d["from"] < d["to"]) {
      sf::st_difference(to, from |> sf::st_union())
    } else {
      sf::st_difference(from, to |> sf::st_union())
    }
      
  }
  
  if (nrow(sf_obj)) { 
    return(lapply(dist, bake_donut))
  }
  
  return(invisible())
}

# Process one flight
flight_process.flightGPX <- function(flight, zones, telemetry, dist) {
  
  # Area of interest
  aoi <- sf::st_bbox(flight[["tracks"]]) |>
    sf::st_as_sfc() |>
    sf::st_buffer(do.call(max,dist) + units::set_units(50L, m)) |>
    sf::st_transform(sf::st_crs(zones)) |>
    sf::st_bbox()
  
  # Zones of interest
  zoi <- filter_on_bbox(aoi, zones)
  
  # Telemetry of interest
  #TODO: Consider data time for telemetry
  toi <- filter_on_bbox(aoi, telemetry)

  # Incursion
  incursions_zoi <- compute_donut(dist, zoi)
  incursions_toi <- compute_donut(dist, toi)
  
  # Do viewshed
}

# system.time({test <- sf::st_crop(zones, aoi)})
# system.time({
#   test2 <- zones[
#     which(
#       .subset2(aoi, "xmin") < .subset2(zones, "xmax") &
#       .subset2(aoi, "xmax") > .subset2(zones, "xmin") &
#       .subset2(aoi, "ymin") < .subset2(zones, "ymax") &
#       .subset2(aoi, "ymax") > .subset2(zones, "ymin")),
#   ]
# })
# ggplot2::ggplot() + ggplot2::geom_sf(data = test) + ggplot2::geom_sf(data = flight$tracks)
# ggplot2::ggplot() + ggplot2::geom_sf(data = test2) + ggplot2::geom_sf(data = flight$tracks)
# 
ggplot() +
  geom_sf(data = incursions_zoi[[3]], fill = "beige") +
  geom_sf(data = incursions_zoi[[2]], fill = "yellow") +
  geom_sf(data = incursions_zoi[[1]], fill = "orange") +
  geom_sf(data = zoi, fill = "red") +
  geom_sf(data = flight$tracks |> sf::st_geometry(), colour = "blue")

```

## Time in Incursion Zones
```{r timeinzones}
```
